<!DOCTYPE html>
<html>
    <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-29519043-1"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());
         gtag('config', 'UA-29519043-1');
        </script>
        
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta property="og:title" content="risou's Lithograph" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://blog.risouf.net" />
        <meta property="og:image" content="https://blog.risouf.net/static/img/sunglass.jpeg" />
        <meta property="og:site_name" content="risou's Lithograph" />
        <meta property="og:description" content="risou's mini blog - writing about software engineering, thinking, private events" /><meta property="fb:app_id" content="2945406965474658" /><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@risou" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.2/css/bulma.min.css">
        <link rel="stylesheet" href="/static/main.css">
        <title>risou's Lithograph</title>
    </head>
    <body>
        <section class="hero is-medium is-bold is-dark">
            <div class="hero-body">
                <div class="container has-text-centered">
                    <h1 class="title is-1">risou's Lithograph</h1>
                </div>
            </div>
        </section>
        <section class="section">
            <div class="container">
                <nav class="level is-mobile">
                    <div class="level-left"></div>
                    <div class="level-right">
                        <p class="level-item">top</p>
                        <p class="level-item"><a href="/list.html">list</a></p>
                    </div>
                </nav>
                <article class="articles">
                    
                    <div class="article">
                        <h1 class="title is-2"><a href="/entry/2023-03-22-moergo-glove80-wireless-spli-ergonomic-keyboard.html">Glove80 という新しいキーボードが届いたので試している</a></h1>
                        <div class="subtitle published">2023-03-22</div>
                        <div class="content">
                            <p><a href="https://www.moergo.com/">MoErgo Glove80 Wireless Split Ergonomic Keyboard</a></p>

<p>Glove80 は、昨年 Kickstarter でクラウドファンディングしていた分割キーボードだ。<br/>
以下のような特徴を持っている。</p>

<ul>
<li>お椀型

<ul>
<li>※お椀型という表現が一般的かはわからない</li>
<li>Kinesis Advantage のような中心がくぼんでいるタイプ</li>
</ul>
</li>
<li>分割キーボード

<ul>
<li>Kinesis も分割キーボードに分類できるが Glove80 は左右が完全に分離している</li>
</ul>
</li>
<li>ロープロファイル</li>
<li>BLE 対応

<ul>
<li>ワイヤレスで複数の端末に繋ぐことができる</li>
<li>左右も有線で繋ぐ必要がない</li>
</ul>
</li>
</ul>


<p>この手のクラウドファンディングはあまり手を出さないようにしているが、これは非常に興味をそそられたので悩みに悩んで投資をした。<br/>
当時はまだ円安が進行する前だったから挑戦できた、というのはあるかもしれない。</p>

<p>当初は昨年秋頃に完成して順次発送する、という計画だったが様々な事情で pledge した全員への発送は3月中旬になったようだ。<br/>
（既に全員への発送が完了したというメールが送られており、居住地によって受け取りのタイミングは前後するだろうが程なく全員が受け取れるはず）<br/>
僕自身は10月くらいからおよそ半年間、まだかまだかと待つことになった。一日千秋とはこのことである。<br/>
開発者の方々は毎月進捗を共有してくれていて、これも楽しみにしていた。<br/>
（iOS の標準機能で英語を翻訳できるのは非常に便利）</p>

<p>今朝届いて、半日ほど触った感触を以下に記しておく。</p>

<h3>思った以上に軽い</h3>

<p>当初から持ち運ぶことも想定しているようだったので、重くはないだろうと思っていたが、手に持ってみると想像以上に軽かった。<br/>
ただ、形状の問題で厚みはどうしても存在するので、持ち運ぶかというと悩ましい。<br/>
持ち運びに適した袋なりケースなりの都合がつけば、持ち運びたくはある。</p>

<h3>打鍵感はかなり良い</h3>

<p>過去に最も使ってきたのは茶軸で、たぶん一番好きなのはピンク軸（静音赤軸）なのだが、選択肢に静音系がなかったので赤軸を選んだ。<br/>
赤軸のロープロファイルは初めてで、どんなものかと思っていたが個人的にはかなり好みだった。<br/>
これについてはキーキャップの材質もあるかもしれない。</p>

<h3>キーボードの土台はちょっと荒削り</h3>

<p>お椀型なので作りの難易度は高そうだが、頑丈さは申し分なさそう。<br/>
ただ、角の部分が尖っており、持ち方によっては痛く感じるかもしれないのは気になるところ。</p>

<h3>足の高さ調節がネジ式なのがちょっと気になる</h3>

<p>6つある足のうちの1つだけが固定されており、残りの5つは高さを調節できるようになっている。<br/>
一番短い状態にしておき、机に置いたときに浮くものだけ、接地するようにネジを緩めることでキーボードが安定する。</p>

<p>そのまま机の上に置いて使う分には問題ないが、場所を動かしたり持ち運んだりしようとすると、ネジを緩めた足がカチャカチャなったり、緩めすぎているとふとした拍子に外れてしまうこともあった。<br/>
これは持ち運びの際にも注意が必要なポイントだと感じる。</p>

<h3>親指キーがどれも押しやすい</h3>

<p>ロープロファイルだからというのもあるかもしれないが、自分が所有する親指用にいくつかのキーを持つキーボード（Kinesis や Ergodox EZ など）と比較して、親指キーの奥側が押しやすいと感じる。<br/>
これまで親指キーは手前は押しやすいものの奥は押しづらい印象があったが、絶妙な高さの違いとロープロファイルという条件が噛み合って奥のキーも押しづらさがないのは非常に良い。</p>

<h3>押し間違いは増えてしまった</h3>

<p>慣れるまでの一時的なものかもしれないが、タイプミスは一時的に増えている。<br/>
Kinesis も結構長期間使っているので、タイプミスはあまり心配いらないかと思ったが、当然全く同じ形状ではないのでタイプミスは増えているように感じる。<br/>
お椀型はどうしても手の大きさや指の長さによって適合度合いが変わってしまうので仕方がない。<br/>
自分の指の長さだと近すぎるように感じるキーがいくつかあるので、これだけは慣れていくしかない。<br/>
とはいえ、自分の手の大きさ、指の長さであれば許容範囲という感じがする。</p>
                        </div>
                    </div>
                
                    <div class="article">
                        <h1 class="title is-2"><a href="/entry/2023-02-10-2023-02-10-golang-maxage-caution.html">Golang で Cookie を扱うときは Max-Age の指定方法に注意が必要</a></h1>
                        <div class="subtitle published">2023-02-10</div>
                        <div class="content">
                            <p>近年では Chrome が Cookie の有効期限の上限を定めるなど、 Cookie を扱う上で有効期限は軽率にしてはいけないものという認識が広がってきているように思う。<br/>
Cookie の有効期限の指定については歴史的経緯で <code>Expires</code> を指定する方法と <code>Max-Age</code> を指定する方法の2つがあり、モダンブラウザと呼ばれるものであれば大体は両方指定されている場合は <code>Max-Age</code> が優先されるようになっている。</p>

<p><code>Max-Age</code> には <strong>「その Cookie がセットされてから何秒後まで有効か」</strong> を整数で渡すことができるようになっており、よく見るものだと「24時間有効とする <code>60 * 60 * 24</code> 」や「1年有効とする <code>60 * 60 * 24 * 365</code> 」という値がコード上ではセットされている。<br/>
当然、実際に通信される際の値は計算済みのものだし、ブラウザでは受け取った日時から指定された秒数を足した絶対時間で Cookie を保持している。</p>

<p><code>Max-Age</code> および <code>Expires</code> が指定されていない場合、その Cookie はセッション終了時に消えるようになっており、ブラウザが閉じられたタイミングで消える。ただしブラウザがセッションを復元する機能を持っている場合、再度ブラウザが開かれたタイミングで Cookie も復元されることもある。</p>

<p>また <code>Max-Age</code> には 0 や負数を設定することもでき、この場合ブラウザ側は有効期限として表現可能な最も古い日時をセットする。当然この表現可能な最も古い日時は過去日時であるため、その Cookie は直ちに破棄される。</p>

<p>さて、ようやく本題に入るが、 Golang で Cookie を扱う際にはおそらく一般的には net/http パッケージの Cookie 構造体を利用すると思う。<br/>
そしてこの Cookie 構造体を用いて Cookie の設定をする際には <code>Max-Age</code> の値のセットの仕方に注意が必要だ。</p>

<p>具体的に注意が必要になるのは 0 である。<br/>
先に書いたように Cookie の仕様としての <code>Max-Age</code> は以下のようになっている。</p>

<ul>
<li><code>Max-Age</code> に正の整数が指定されていれば、 Cookie を受け取った時間から <code>Max-Age</code> 秒後にその Cookie は有効ではなくなる</li>
<li><code>Max-Age</code> に 0 もしくは負の整数が指定されていれば、その Cookie は直ちに破棄される</li>
</ul>


<p>しかし net/http パッケージの Cookie 構造体が受け取る <code>MaxAge</code> フィールドの挙動は若干異なる。<br/>
<a href="https://pkg.go.dev/net/http#Cookie">https://pkg.go.dev/net/http#Cookie</a> には <code>MaxAge</code> フィールドについて以下のようにコメントが記載されている。</p>

<pre><code class="golang">    // MaxAge=0 means no 'Max-Age' attribute specified.
    // MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'
    // MaxAge&gt;0 means Max-Age attribute present and given in seconds
</code></pre>

<p>つまりこうだ。</p>

<ul>
<li><code>MaxAge</code> に正の整数が指定されていれば、 Cookie を受け取った時間から <code>MaxAge</code> 秒後にその Cookie は有効ではなくなる（ <code>Max-Age</code> にそのまま値が渡される）</li>
<li><code>MaxAge</code> に負の整数が指定されていれば、その Cookie は直ちに破棄される（ <code>Max-Age</code> には 0 が設定される）</li>
<li><code>MaxAge</code> に 0 が指定されていれば、そのCookieはセッションが閉じられるまで有効である（ <code>Max-Age</code> を <strong>指定しない</strong> ）</li>
</ul>


<p>net/http の Cookie 構造体経由で Cookie を扱うのであれば Cookie 構造体の <code>MaxAge</code> とリクエスト／レスポンスで扱われる <code>Max-Age</code> の違いを理解しておく必要がある。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> <code>MaxAge</code> (Golang) </th>
<th style="text-align:center;"> <code>Max-Age</code> (HTTP) </th>
<th style="text-align:left;"> 有効期限 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> N > 0 </td>
<td style="text-align:center;"> N </td>
<td style="text-align:left;"> N 秒後まで </td>
</tr>
<tr>
<td style="text-align:center;"> N &lt; 0 </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:left;"> 期限切れ </td>
</tr>
<tr>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> - </td>
<td style="text-align:left;"> セッションが閉じられるまで </td>
</tr>
</tbody>
</table>

                        </div>
                    </div>
                
                    <div class="article">
                        <h1 class="title is-2"><a href="/entry/2022-10-24-hsts-on-local-environment.html">Strict-Transport-Security がローカルの開発環境にどう影響するか</a></h1>
                        <div class="subtitle published">2022-10-24</div>
                        <div class="content">
                            <h2>Strict Transport Security とは</h2>

<p><a href="https://www.rfc-editor.org/rfc/rfc6797">RFC 6797: HTTP Strict Transport Security (HSTS)</a></p>

<p>Strict Transport Security とは Web サイトへの接続の安全性を高めるための手法のひとつとして策定されている仕組みである。</p>

<p>Strict Transport Security が設定されている Web サイトへの接続は、 たとえ http でのアクセスであったとしても https を用いて行われるようになっている。</p>

<h2>Strict Transport Security の仕組み</h2>

<p>当然、勝手にそのようになってくれるわけではなく、これを実現するための前提となる仕組みが存在する。</p>

<p>サーバ側は HTTPS でリクエストしてもらうために、 Strict Transport Security の対象であることを明示する必要がある。<br/>
具体的にはレスポンスヘッダに Strict-Transport-Security フィールドを付与し、適切な値を添えて返却することで「次回以降、このドメインには HTTPS でアクセスしてください」という表明を行う。</p>

<p>これを受けてクライアント側（主にブラウザ）はレスポンスヘッダに Strict-Transport-Security フィールドを見つけると、その内容に応じて次回以降のアクセスを HTTPS に切り替えてくれる。</p>

<p>大まかな流れとしては以上だが、 Strict Transport Security を利用するにあたっては、もう少し詳細に知っておくべきことがいくつかある。</p>

<h2>Strict Transport Security を深く知る</h2>

<h3>初回アクセスから HTTPS でのリクエストを求める</h3>

<p>Strict Transport Security が実現したいのは Web サイトへの HTTPS でのアクセスだ。<br/>
しかしサーバ側がこれを指定しているかどうかは一度アクセスしないとわからない。<br/>
つまりどう頑張っても初回のリクエストが HTTP で行われた場合にはその恩恵を受けられない。</p>

<p>この問題を解消する方法として HSTS preload という仕組みがある。</p>

<p><a href="https://hstspreload.org/">HSTS Preload List Submission</a></p>

<p>ここで管理されている HSTS preload list に入っているドメインについては、ブラウザがこのリストを参照することで初回アクセスから HTTPS を強制してくれる。</p>

<h3>HTTP リクエストのレスポンスに付与された Strict-Transport-Security フィールドは参照されない</h3>

<p>初回のリクエストが HTTP で行われる問題については HSTS preload によって解消されるが、もし HSTS preload list に含まれていないドメインに対して HTTP でリクエストが行われた場合、そのドメインへのアクセスは次から HTTPS に切り替えられるか。</p>

<p>実は、答えは No である。</p>

<p>なぜなら、ブラウザは HTTP でリクエストして得られたレスポンスに付与されている Strict-Transport-Security フィールドを無視するからだ。<br/>
これは「そもそもその HTTP リクエスト、ひいてはそのレスポンスが安全であることが保証できない」ためである。<br/>
要するに HTTPS でリクエストしない限り、「次回以降 HTTPS でリクエストする」設定にはならないようにできている。<br/>
だからこそ HSTS preload の設定が重要であるし、サーバ側は HTTP でリクエストを受けた場合にリダイレクトして HTTPS でのアクセスに切り替えるように設定しておく必要がある。</p>

<h2>Strict Transport Security の設定ができているサイトをローカルで動かす場合</h2>

<p>開発している Web サービスにおいて Strict Transport Security を設定したい場合、ローカルでの開発環境についても HTTPS を扱えるように証明書等を準備する必要がある、とは限らない。<br/>
というのも先に述べたとおり Strict Transport Security が有効になるためには HTTPS でアクセスされる必要があるからだ。</p>

<p>たとえば手元で <code>http://localhost/</code> などにアクセスしてサービスの挙動を確認できるようにしているのであれば、サービス上のどこかで <code>https://localhost/</code> へのアクセスに切り替わる導線でもなければ Strict Transport Security が有効になることはない。</p>

<p>したがって、環境ごとに Strict-Transport-Security フィールドをセットするかどうかを分岐させる必要はない。</p>

<h2>ローカルで Strict Transport Security が機能して HTTP リクエストできない場合</h2>

<p>人によっては <code>http://localhost/</code> にアクセスしたら <code>https://localhost/</code> にリダイレクトされる、という人もいるかもしれない。<br/>
そうなっている場合、疑うべきは「ブラウザがキャッシュしている HSTS のリストに <code>localhost</code> が含まれている」可能性だ。</p>

<p>複数のサービスを開発していれば、ローカルでも証明書を使って HTTPS 化していることもある。<br/>
そのサービスが Strict Transport Security を設定していれば、ブラウザは <code>localhost</code> を HSTS のリストに入れているかもしれない。</p>

<p>こういった場合の対処法としては <code>/etc/hosts</code> などで 127.0.0.1 に紐づけるドメインを増やしておくなどがある。<br/>
当然ブラウザのキャッシュを削除することで HSTS のリストから外すという選択肢もあるが、そもそも HSTS を使っているサービスを手元で開発し続けるのであれば現実的ではない。</p>
                        </div>
                    </div>
                
                    <div class="article">
                        <h1 class="title is-2"><a href="/entry/2022-10-10-github-api-v4-lack-of-some-functions.html">GitHub API v4 では v3 でできることのいくつかができない</a></h1>
                        <div class="subtitle published">2022-10-10</div>
                        <div class="content">
                            <p>最近いろいろな事情があり、 API 経由で GitHub からデータを取得したり変更をかけたりしたくて GitHub API について調べたり実際に叩いてみたりしていた。</p>

<p>GitHub の API は現行では REST API である v3 と GraphQL API である v4 が提供されており、 v4 は v3 の後継というよりは新規に作り直しているもの、という立ち位置のようだ。</p>

<p>基本的には最新版を使うのが良いだろうという認識のもと（幸いにも GraphQL に触れた経験はあったので） v4 を使ってやりたいことを実現するコードを書き進めていた。<br/>
が、あることをやろうとして、それを実現する機能が v4 では提供されていなさそうだ、という事に気づいた。<br/>
やろうとしていたのは、 GitHub Organization における Team で、要は作業の一環として複数のチームを一気に作りたかったのだ。<br/>
だが GitHub API v4 のスキーマを見ていると、 <code>createTeam</code> という感じの mutation が存在しない。<br/>
v3 のドキュメントを見に行ってみると <a href="https://docs.github.com/ja/rest/teams/teams#create-a-team">Teams - GitHub Docs</a> とあり POST で <code>/orgs/{org}/teams</code> にリクエストを送ることでチームを作れそうである。</p>

<p>と、ここまで書いておきながら本当に API v4 でできないのか、まだよくわかっていない。<br/>
GitHub 上で GitHub API を活用してそうなリポジトリをいくつか見て回ったが、そのうちのいくつかは v3 と v4 を併用しているようだったので、「v3 でできることは全て v4 でできる」というわけではなさそうに見える。</p>

<p>ということで、自分としては v3 / v4 を併用するか、 v3 なら自分がやりたいことが全てできると信じて v3 のみに統一するか、という判断が必要そうだ。</p>
                        </div>
                    </div>
                
                    <div class="article">
                        <h1 class="title is-2"><a href="/entry/2022-10-03-begin-learning-how-to-solve-rubiks-cube.html">ルービックキューブで遊び始めた</a></h1>
                        <div class="subtitle published">2022-10-03</div>
                        <div class="content">
                            <p>たぶん半年くらい前に見かけてから少し興味を持っていたルービックキューブを、つい先日他のものを購入するついでに購入した。</p>

<p>買ったのは、 <a href="https://toribo.jp/">TORIBO ファーストキューブセット</a> という商品。</p>

<p><img src="/static/img/toribo-rubiks-cube.jpg" alt="TORIBO のルービックキューブ" /></p>

<p>リンク先を見てもらうとわかるが、「3x3x3 キューブ6面完成攻略書」という揃え方の説明書のようなものが入っており、そこに書かれている手順どおりに動かしていくことで最終的に6面揃えることができるという、初心者向けのキットだ。<br/>
また、ルービックキューブ自体も2つ入っており、1つは普通のルービックキューブ、もう1つはいくつかのキューブの面に目印がついている初心者向けのルービックキューブになっている。<br/>
後者の初心者向けルービックキューブに描かれている目印が6面完成攻略書にも使われており、手順に慣れるまでの動かし方をサポートしてくれる。</p>

<p>6面完成攻略書の内容は、おそらく大筋ではルービックキューブのセオリーに則っているように思えるもので、素人ながら「なるほどたしかにこの手順でやるのが良さそう」と納得できるものだった。<br/>
そういう意味では手順自体は目新しさはなく、最も説明したいのは詳細なそれぞれの手順におけるキューブの動かし方なのだろう。<br/>
キューブの動かし方は思っていたよりも少ない手順でできていてすごいな、と思うものの、僕自身はこういったものを丸覚えして使いこなすのはあまり得意ではなく、「どうしてその動かし方で目的が達成されるのか」「ある箇所のキューブを目的の場所に動かすにはこの順番で回す必要がある」といった部分を理解することで自分のものにしていくタイプなので、攻略書の内容を自分なりに分解していく必要を感じている。<br/>
パッと目を通して試してみて、前半はすんなり理解できたので、後半さえ理解できれば、という状態だが……。</p>

<p>今日届いて1時間弱ほど触ってみた今の時点では、攻略書の内容をベースにアレンジを加えたりよくわかってない部分を丸暗記しながら、なんとか6面を5分以内くらいで揃えられる状態にまで習得できた。<br/>
ここから先は後半の動かし方を「なぜその動かし方でやりたいことができるのか」理解しながら自分のものにしていくことになるので、安定するまでには、あるいは人に教えられるようになるまでにはもう少しかかりそうだ。</p>
                        </div>
                    </div>
                
                </article>
            </div>
        </section>
        <footer class="footer">
            <div class="content has-text-centered">
                Copyright &copy; 2019- risou All Rights Reserved.
            </div>
        </footer>
    </body>
</html>
